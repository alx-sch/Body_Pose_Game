import cv2
import time
import mediapipe as mp
import os
import numpy as np
import sys
import random
from tensorflow.keras.models import load_model
import pygame  # Import pygame
from utils_2 import (
    initialize_pose_model,
    process_frame,
    draw_bold_text,
    extract_landmarks,
    # predict_pose,
    predict_pose_2,
)

# Constants
COUNTDOWN = int(sys.argv[1])
ROUNDS = int(sys.argv[2])
POSES = ["Stand", "Squat", "X", "Hide", "Pose"]
label_mapping = {"X": 0, "Hide": 1, "Pose": 2, "Squat": 3, "Stand": 4}

save_folder = "test_play_2"


def main():
    model = load_model("./models/model_SU_1.h5")

    cap = cv2.VideoCapture(0)

    last_capture_time = time.time()
    countdown = False
    count = COUNTDOWN  # Initialize count to 0
    rounds_left = ROUNDS
    previous_pose = None
    current_pose = random.choice(POSES)
    points = 0
    point_made = False
    no_point_made = False

    pose = initialize_pose_model()

    # Initialize pygame for audio
    pygame.init()
    pygame.mixer.init()

    pygame.mixer.music.load("./sounds/strike_pose.mp3")

    confirmation_sound = pygame.mixer.Sound("./sounds/confirmation.mp3")
    countdown_sound = pygame.mixer.Sound("./sounds/countdown.mp3")

    pose_sounds = {pose: pygame.mixer.Sound(f"./sounds/{pose}.mp3") for pose in POSES}

    all_points_sound = pygame.mixer.Sound("./sounds/game_over_100.mp3")
    many_points_sound = pygame.mixer.Sound("./sounds/game_over_51_99.mp3")
    few_points_sound = pygame.mixer.Sound("./sounds/game_over_50.mp3")

    point_sound = pygame.mixer.Sound("./sounds/point.mp3")
    no_point_sound = pygame.mixer.Sound("./sounds/no_point.mp3")

    audio_played = False
    pose_sound_played = False
    countdown_sound_played = False

    while True:
        success, frame = cap.read()

        if success:
            rect_top_left = (950, 20)
            rect_bottom_right = (350, 700)
            rect_color = (0, 255, 0)

            cv2.rectangle(
                frame, rect_top_left, rect_bottom_right, rect_color, thickness=6
            )

            results, frame = process_frame(frame, pose)
            frame = cv2.flip(frame, 1)

            if countdown:
                if rounds_left > 0:
                    if point_made:
                        # Blink the screen in green
                        green_rect = np.zeros_like(frame)
                        green_rect[:, :, 1] = 255  # Set green channel to 255

                        alpha = 0.5
                        frame = cv2.addWeighted(frame, 1 - alpha, green_rect, alpha, 0)

                        # After a short duration, reset point_made
                        if time.time() - point_made_time >= 0.2:
                            point_made = False

                    elif no_point_made:
                        # Blink the screen in red
                        red_rect = np.zeros_like(frame)
                        red_rect[:, :, 2] = 255

                        alpha = 0.5
                        frame = cv2.addWeighted(frame, 1 - alpha, red_rect, alpha, 0)

                        # After a short duration, reset point_made
                        if time.time() - no_point_made_time >= 0.2:
                            no_point_made = False

                    text = f"{current_pose.upper()}: {count} s"
                    text_position = (430, 100)

                    draw_bold_text(frame, text, text_position, color=(0, 0, 255))

                    game_over_sound_played = False

                    if not pose_sound_played:
                        sound = pose_sounds.get(current_pose)
                        if sound:
                            sound.play()

                        pose_sound_played = True

                    """
                    # display frame / videostream in window
                    cv2.imshow("Pose Detection", frame)
                    """

                    if time.time() - last_capture_time >= 1:
                        count -= 1
                        last_capture_time = time.time()

                    if count == 0:
                        count = COUNTDOWN

                        previous_pose = current_pose

                        while current_pose == previous_pose:
                            current_pose = random.choice(POSES)

                        timestamp = int(time.time())

                        landmark_coordinates = extract_landmarks(results)

                        ###
                        landmarks_folder = f"{save_folder}/landmarks"
                        picture_folder = f"{save_folder}/pics"

                        if not os.path.exists(picture_folder):
                            os.makedirs(picture_folder)
                        if not os.path.exists(landmarks_folder):
                            os.makedirs(landmarks_folder)

                        filename_pictures = f"{picture_folder}/{timestamp}.jpg"
                        filename_landmarks = f"{landmarks_folder}/{timestamp}.npy"
                        ####

                        cv2.imwrite(filename_pictures, frame)
                        np.save(filename_landmarks, landmark_coordinates)

                        predicted_pose = predict_pose_2(
                            landmark_coordinates, label_mapping, model
                        )

                        print(f"Rounds left: {rounds_left}")
                        print(f"Pose to pose: {previous_pose}")
                        print(f"Recorded Pose: {predicted_pose}")

                        if predicted_pose == previous_pose:
                            point_sound.play()
                            point_made = True
                            point_made_time = time.time()

                            points += 1

                            print("***")
                            print("Good job!")
                            print(f"Points:{points}/{ROUNDS}")
                        else:
                            no_point_sound.play()
                            no_point_made = True
                            no_point_made_time = time.time()

                            print("***")
                            print("Better luck next time!")
                            print(f"Points:{points}/{ROUNDS}")

                        rounds_left -= 1
                        pose_sound_played = False

                if rounds_left == 0:
                    if not game_over_sound_played:
                        print("******")
                        print("Game Over!")
                        print(f"Points:{points}/{ROUNDS}")

                        if points == ROUNDS:
                            all_points_sound.play()
                        elif points < (ROUNDS / 2):
                            few_points_sound.play()
                        else:
                            many_points_sound.play()

                        game_over_sound_played = True

                    white_rect = np.zeros_like(frame) + 255

                    alpha = 0.5
                    frame = cv2.addWeighted(frame, 1 - alpha, white_rect, alpha, 0)

                    # Show restart message
                    text = "GAME OVER!"
                    text_position = (350, 100)

                    text_points = f"Points: {points}/{ROUNDS}"
                    text_position_points = (350, 250)

                    draw_bold_text(
                        frame,
                        text,
                        text_position,
                        font_scale=3,
                        color=(0, 0, 255),
                        thickness=3,
                    )

                    draw_bold_text(
                        frame,
                        text_points,
                        text_position_points,
                        font_scale=3,
                        color=(255, 0, 0),
                        thickness=3,
                    )

                    if int(time.time() * 2) % 2 == 0:
                        text_2 = "Restart: 'SPACE'"
                        text_position_2 = (250, 560)

                        text_3 = "Exit: 'Q'"
                        text_position_3 = (450, 660)

                        draw_bold_text(
                            frame,
                            text_2,
                            text_position_2,
                            font_scale=3,
                            color=(0, 0, 255),
                            thickness=3,
                        )

                        draw_bold_text(
                            frame,
                            text_3,
                            text_position_3,
                            font_scale=3,
                            color=(0, 0, 255),
                            thickness=3,
                        )

                    # Display frame / videostream in window
                    cv2.imshow("Pose Detection", frame)

                    key = cv2.waitKey(5)
                    if key == ord("q"):  # Press 'q' to exit
                        break
                    if key == ord(" "):  # Press 'SPACE' to restart
                        countdown = True
                        rounds_left = ROUNDS
                        points = 0
                        last_capture_time = time.time()

                        # Randomly select a new pose to start the game
                        previous_pose = None
                        while current_pose == previous_pose:
                            current_pose = random.choice(POSES)

            else:
                white_rect = np.zeros_like(frame) + 255

                alpha = 0.5
                frame = cv2.addWeighted(frame, 1 - alpha, white_rect, alpha, 0)

                if int(time.time() * 2) % 2 == 0:
                    text = "Press 'SPACE' to start"
                    text_position = (270, 650)
                    draw_bold_text(
                        frame,
                        text,
                        text_position,
                        font_scale=2,
                        color=(255, 0, 0),
                        thickness=2,
                        offset=1,
                    )

                text = "STRIKE"
                text_position = (470, 110)
                draw_bold_text(
                    frame,
                    text,
                    text_position,
                    font_scale=3,
                    color=(0, 0, 255),
                    thickness=4,
                    offset=3,
                )

                text = "A POSE!"
                text_position = (440, 210)
                draw_bold_text(
                    frame,
                    text,
                    text_position,
                    font_scale=3,
                    color=(0, 0, 255),
                    thickness=4,
                    offset=3,
                )

                text = "Predictive Body Pose Classification via"
                text_position = (170, 450)
                draw_bold_text(
                    frame,
                    text,
                    text_position,
                    font_scale=1.5,
                    color=(0, 0, 0),
                    thickness=2,
                    offset=2,
                )

                text = "Sequential Neural Network Analysis"
                text_position = (215, 510)
                draw_bold_text(
                    frame,
                    text,
                    text_position,
                    font_scale=1.5,
                    color=(0, 0, 0),
                    thickness=2,
                    offset=2,
                )

                text = "in a Dynamic Videogame"
                text_position = (335, 570)
                draw_bold_text(
                    frame,
                    text,
                    text_position,
                    font_scale=1.5,
                    color=(0, 0, 0),
                    thickness=2,
                    offset=2,
                )

                text = "A game by Alexander Schenk @SPICED, August 2023"
                text_position = (200, 700)
                draw_bold_text(
                    frame,
                    text,
                    text_position,
                    font_scale=1,
                    color=(0, 0, 0),
                    thickness=1,
                    offset=1,
                )

            if not audio_played:
                pygame.mixer.music.set_volume(0.1)
                pygame.mixer.music.play(-1)  # Start playback
                audio_played = True

            # display frame / videostream in window
            cv2.imshow("Pose Detection", frame)

            key = cv2.waitKey(5)
            if key == ord("q"):  # Press 'q' to exit
                break

            if key == ord(" "):
                if not countdown_sound_played:
                    countdown_sound.play()
                    countdown_sound_played = True

                countdown = (True,)
                last_capture_time = time.time()

        else:
            print("Closing camera.")
            break

    cap.release()
    cv2.destroyAllWindows()


if __name__ == "__main__":
    main()
